# Cleverence — Тестовое задание на позицию C# Developer

Данный репозиторий содержит решения трёх задач, выполненных в рамках отбора в компанию **Cleverence**.  
Каждое решение демонстрирует:
- Чёткую архитектуру и разделение ответственности
- Покрытие тестами (unit, integration, stress)
- Поддержку расширяемости и обработки ошибок

[Оригинальное задание (Яндекс Диск)](https://disk.360.yandex.ru/i/LriAyn2ruL4iDQ)

## Содержание
- [Структура проекта](#project_struct)
- [Задача 1: Алгоритм сжатия текста](#task1)
- [Задача 2: Потокобезопасный счётчик](#task2)
- [Задача 3: Консольная утилита стандартизации логов](#task3)
- [Общие принципы разработки](#general_dev_principles)
- [Области для улучшения](#areas_to_improve)

---

## <a id="project_struct">Структура проекта</a>

|Папка| Описание|
|-------|-----|
| Applications | Консольные приложения и демо-проекты  |
| Libraries    | Основные библиотеки (логика задач)  |
| Tests  | Тесты (unit, integration, stress)  |

---

## <a id="task1">Задача 1: Алгоритм сжатия текста</a>

**Описание**: Реализация алгоритма RLE-сжатия строк с особым форматом: `sc` (где `s` — символ, `c` — количество), без указания счётчика для одиночных символов.

### Проекты
- **Библиотека**: `Cleverence.TextCompression`
- **Тесты**: `Cleverence.TextCompression.Tests`
- **CLI-приложение**: `Cleverence.TextCompression.ConsoleApp`

### Структура решения

Проект разделён на три основные части:

#### 1. **Библиотека (`Cleverence.TextCompression`)**
- Определяет интерфейс `IStringTransformer` для унификации алгоритмов трансформации строк.
- Содержит реализацию RLE в классе `RunLengthEncoder`.
- Обеспечивает:
  - Валидацию входных данных (только `a–z` для исходной строки, `a–z` + цифры — для сжатой).
  - Защиту от превышения максимальной длины строки в .NET (`0x3FFFFFDF`).

#### 2. **Консольное приложение (`Cleverence.TextCompression.ConsoleApp`)**
Предоставляет CLI для работы с алгоритмами компрессии:
```cmd
help        # Показать справку
list        # Список доступных алгоритмов
compress    RunLengthEncoder input.txt      compressed.txt
decompress  RunLengthEncoder compressed.txt decompressed.txt
```
Использует **рефлексию** для автоматического обнаружения реализаций `IStringTransformer` в библиотеке `Cleverence.TextCompression`.

#### 3. **Юнит-тесты (`Cleverence.TextCompression.Tests`)**
- Покрывают:
  - Базовые и граничные сценарии;
  - Обработку ошибок (некорректные символы, нулевой счётчик, переполнение);
  - Round-trip корректность: `Compress → Decompress → оригинал`.

### Как запустить
```cmd
git clone https://github.com/ammv/Cleverence
cd Cleverence
dotnet run --project Cleverence.TextCompression.ConsoleApp help
```

---

## <a id="task2">Задача 2: Потокобезопасный счётчик с приоритетом чтения</a>

**Описание**: Реализация статического класса-«сервера» с методами `GetCount()` и `AddToCount(int value)`, обеспечивающего:
- Параллельное чтение без блокировок
- Последовательную запись
- Блокировку чтения во время записи

### Проекты
- **Библиотека**: `Cleverence.Network`
- **Тесты**: `Cleverence.Network.Tests` (включая стресс-тесты)
- **CLI Демо-сервер**: `Cleverence.Network.TcpServer`
- **CLI Демо-клиент**: `Cleverence.Network.TcpClient`

> «TCP-клиент и сервер — **демонстрация** потокобезопасности и работы механизма синхронизации, а не обязательная часть требования.»

### Архитектура

Проект состоит из трех ключевых компонентов:

#### 1. **Библиотека (`Cleverence.Network`)**
- Статический класс `Server` с общим целочисленным счётчиком `_count`.
- Методы:
  - `GetCount()` — безопасное чтение (с read-блокировкой);
  - `AddToCount(int value)` — атомарное изменение (с write-блокировкой).
- В режиме `DEBUG` содержит методы с искусственной задержкой (`GetCountDelay`, `AddToCountDelay`) для тестирования блокировок под нагрузкой.

#### 2. **Обертка над ReaderWriterLockSlim (`Cleverence.Network.Synchronization.ReadWriteLockCustom`)**
`ReaderWriterLockSlim` - класс, который используется для обеспечения синхронизации в многопоточной среде и позволяет нескольким потокам одновременно читать ресурс, но только один может записывать данные.

`ReadWriteLockCustom` является оберткой над `ReaderWriterLockSlim` и предоставляет **RAII-подобный интерфейс** через `IDisposable` токены:

```csharp
var _lock = new ReadWriteLockCustom();

using (_lock.WriteLock())
{
    _count += value;
}

using (_lock.ReadLock())
{
    return _count;
}
```

#### 3. **Тесты**
- **Юнит-тесты** (`ServerUnitTest`, `ReadWriteLockCustomUnitTest`):
  - Проверяют базовую функциональность;
  - Убеждаются, что исключения не приводят к утечке блокировок;
  - Тестируют корректность изоляции чтения и записи.
- **Стресс-тесты** (`ServerStressTest`, `ReadWriteLockCustomStressTest`):
  - Запускают десятки потоков-читателей и писателей;
  - Проверяют отсутствие гонок, взаимоблокировок и повреждения данных;
  - Убеждаются, что итоговое значение счётчика всегда корректно.

 ### Как запустить (Сервер и клиент)
 Cleverence.Network.TcpServer в режиме DEBUG добавляет задержку в 5000 миллисекунд
 
```cmd
git clone https://github.com/ammv/Cleverence
cd Cleverence
start cmd.exe /C "dotnet run --project Cleverence.Network.TcpServer"
start cmd.exe /C "dotnet run --project Cleverence.Network.TcpClient"
```

Cleverence.Network.TcpClient предоставляет CLI для работы с сервером:
```cmd
> get        # Получить текущее значение счетчика
> add N      # Увеличить счетчик на значение N
```

---

## <a id="task3">Задача 3: Консольная утилита стандартизации логов</a>

**Описание**: Преобразование лог-файлов из двух различных форматов в единый, нормализованный табулированный формат, обеспечивающий:
- Поддержку двух входных форматов: space-delimited и pipe-delimited
- Типизированный парсинг полей (дата, время, уровень логирования, сообщение, вызвавший метод)
- Нормализацию уровней логирования (`INFORMATION` → `INFO`, `WARNING` → `WARN`)
- Обработку отсутствующих полей (замена на `DEFAULT`)
- Сохранение непарсируемых строк в отдельный файл для последующего анализа

### Проекты
- **Библиотека**: `Cleverence.LogTransform`
- **Тесты**: `Cleverence.LogTransform.Tests` (unit + интеграционные)
- **CLI Утилита**: `Cleverence.LogTransform.ConsoleApp`
- **Интеграционные тесты CLI**: `Cleverence.LogTransform.ConsoleApp.Tests`

### Архитектура

Ядро решения — библиотека `Cleverence.LogTransform` — спроектирована как **гибкий фреймворк для типизированной обработки структурированных логов**. Она не просто решает конкретную задачу стандартизации — она предоставляет инструменты для создания и преобразования **любых форматов логов в runtime**.

#### 1. **Библиотека (`Cleverence.LogTransform`)**

Ключевая идея — **полная декомпозиция описания формата**. Каждый лог-формат задаётся как набор именованных частей (`ILogFormatPart`), каждая из которых имеет:
- **Семантический тип** (`DATETIME`, `INTEGER`, `TEXT` и др.)
- **Кастомный парсер** — `Func<string, object?>` для преобразования строки в значение
- **Кастомный форматтер** — `Func<object?, string>` для обратного преобразования

Это позволяет описывать форматы любой сложности:

```csharp
// Пример описания формата для лога: 2025-03-10 15:14:51.5882| INFO|11|MobileComputer.GetDeviceId| Device id: '@MINDEO-M40-D-410244015546'
var partSet = new LogFormatPartSetBuilder()
    .AddPart("datetime", Models.LogFormatPartType.DATETIME,
        s => DateTime.ParseExact(s, "yyyy-MM-dd HH:mm:ss.ffff", CultureInfo.InvariantCulture))
    .AddPart("level", Models.LogFormatPartType.OTHER, s => LogLevelUtils.StringToEnum(s))
    .AddPart("threadId", Models.LogFormatPartType.INTEGER, s => int.Parse(s))
    .AddPart("callingMethod", Models.LogFormatPartType.TEXT, _stubParser)
    .AddPart("message", Models.LogFormatPartType.TEXT, _stubParser)
    .Build();

var myFormat = new DelimetedLogFormat('|', partSet, false);
```

Библиотека из коробки предоставляет два готовых типа форматов:
- **`DelimetedLogFormat`** — для логов, разделённых символом (с поддержкой или без квотирования полей)
- **`RegexLogFormat`** — для сложных, неструктурированных логов через именованные группы регулярных выражений

Но если их недостаточно — **вы можете реализовать свой тип формата через интерфейс `ILogFormat` или абстракный класс `LogFormatBase`**.

#### **Трансформация как конфигурация**

Процесс преобразования **полностью декларативен**. Связка «формат → функция преобразования» инкапсулирована в `FormatBoundLogTransformer`:

```csharp
var transform = new Func<LogEntry, LogEntry>(entry =>
{
    var values = new Dictionary<string, object?>
    {
        ["date"] = entry.GetDateTimeValue("datetime"),
        ["time"] = entry.GetDateTimeValue("datetime"),
        ["level"] = entry.GetValue<LogLevel>("level"),
        ["callingMethod"] = entry.GetStringValue("method") ?? "DEFAULT",
        ["message"] = entry.GetStringValue("message")
    };
    return new LogEntry(outputFormat, new ReadOnlyDictionary<string, object?>(values));
});
```

Вся логика маппинга полей, нормализации значений и обработки отсутствующих данных **полностью находится в пользовательском коде**, что даёт абсолютную гибкость.

#### **Композиция и обработка потоков**

Готовая цепочка обработки собирается из независимых компонентов:
- **`LogParser`** — принимает список форматов и находит подходящий
- **`LogTransformer`** — применяет правильное преобразование по входному формату
- **`LogFormatter`** — безопасно форматирует результат в строку

Эта архитектура позволяет легко:
- Добавлять новые входные форматы
- Создавать разные выходные форматы (не только табулированный)
- Встраивать обработку логов в другие системы (не только CLI)

[Пример сервиса для преобразования логов из консольного приложения](Cleverence.LogTransform.ConsoleApp/LogTransformationService.cs)

#### 2. **Консольное приложение (`Cleverence.LogTransform.ConsoleApp`)**

`Cleverence.LogTransform.ConsoleApp` — это **демонстрация** возможностей библиотеки. Он показывает, как за несколько строк кода собрать утилиту для стандартизации логов.

Описание работы:
- Читает входной файл построчно
- Преобразует каждую строку в единый формат
- Сохраняет:
  - Успешно обработанные строки в `<output>`
  - Непарсируемые строки в `<problems>`
- Выводит статистику по завершении обработки
- Поддерживает команду `help` с примерами форматов и инструкциями

#### 3. **Тестирование**
- **Unit-тесты**:
  - Покрытие всех компонентов библиотеки
  - Проверка граничных случаев и обработки ошибок
- **Интеграционные тесты**:
  - End-to-end сценарии: парсинг → преобразование → форматирование
  - Тесты обработки ошибок файловой системы (отсутствующий файл, заблокированный файл)
  - Валидация CLI через перехват `Console.Error`
- **Тесты консольного приложения**:
  - Работа с реальными файлами во временных каталогах
  - Проверка корректности обработки смешанных валидных и невалидных логов

### Как запустить

```cmd
git clone https://github.com/ammv/Cleverence  
cd Cleverence
dotnet run --project Cleverence.LogTransform.ConsoleApp help
```

**Пример использования**:
```cmd
dotnet run --project Cleverence.LogTransform.ConsoleApp input.log output.log problems.log
```

Где:
- `input.log` — файл с логами в одном из поддерживаемых форматов
- `output.log` — результат стандартизации (tab-separated)
- `problems.log` — строки, которые не удалось распарсить

**Форматы логов**:
- **Формат 1**: `10.03.2025 15:14:49.523 INFORMATION Версия программы: '3.4.0.48729'`
- **Формат 2**: `2025-03-10 15:14:51.5882| INFO|11|MobileComputer.GetDeviceId| Код устройства: '@MINDEO-M40-D-410244015546'`
- **Выходной формат для формата 1**: `10-03-2025  15:14:49.523  INFO  DEFAULT	Версия программы: '3.4.0.48729'`
- **Выходной формат для формата 2**: `10-03-2025  15:14:51.5882  INFO  MobileComputer.GetDeviceId  Код устройства: '@MINDEO-M40-D-410244015546'`

---

## <a id="general_dev_principles">Общие принципы разработки</a>

- **Тестирование**: каждая библиотека покрыта unit- (интеграционными тестами в большинстве случаев); для задачи 2 реализованы стресс-тесты.
- **Архитектура**: чёткое разделение на библиотеки, приложения и тесты.
- **Инструменты**: .NET 8, C#, NUnit 3, Visual Studio.

---

## <a id="areas_to_improve">Области для улучшения</a>

### Общие

- **Несогласованность стиля оформления кода**  
  В проекте наблюдается **неоднородность форматирования**: отступы, расположение фигурных скобок, пробелы вокруг операторов и именование приватных членов могут отличаться между файлами или даже внутри одного файла.

### Cleverence.LogTransform

1. **Ограничение на символ-разделитель**  
   Текущая реализация `ILogFormat` поддерживает только **один символьный разделитель** (`char`). Это не позволяет работать с форматами, где поля разделяются **многосимвольными последовательностями**. Для таких случаев требуется использовать `RegexLogFormat`, что усложняет конфигурацию.

2. **Отсутствие строителя для `LogEntry`**  
   При ручном преобразовании лога из одного формата в другой необходимо вручную создавать словарь значений и оборачивать его в `ReadOnlyDictionary`. Отсутствие **fluent-строителя** (`LogEntryBuilder`) увеличивает шаблонный код и снижает читаемость функций трансформации.

3. **Обязательное указание парсера для всех частей формата**  
   Даже если формат используется **только для вывода** (например, как цель трансформации), каждому `ILogFormatPart` всё равно требуется корректный `parser`. Это приводит к необходимости создавать «заглушечные» парсеры (`s => s`), которые не используются в реальности.  
   Идеальное решение — **разделить интерфейсы**: один для парсинга (`IParsableLogFormat`), другой для форматирования (`IFormattableLogFormat`), или сделать парсер опциональным с валидацией на этапе использования.
